#ООП - базовая теория и примеры

##Создание класса, ега атрибуты и методы
Чтобы создать класс на языке python, вам необходимо воспользоваться ключевым словоом _class_
и написать седующую конструкцию:
```python
class Car:
    """Описание класса"""
```
Сейчас данный класс ни чего не делает, давайте расширим его функционал, добавив ему атрибуты и методы, но 
предварительно разберемся что они из себя представляют. 
>Атрибут класса-это по сути обычная переменная в языке python например как показано ниже:
```python
class Car:
    name = 'car name' #Здесь мы объявили атрибут класса, который на данный момент хранит в себе строку 
```
>Метод класса-это по сути та же функций на языке python, целью которой является расширение возможностей самого класса (в нашем примере мы добавим функцию завести машину), но она находится внутри класса и поэтому носит такое гордое название "Метод класса", ещё раз фактически это обычная функция на языке python
```python
class Car:
    name = 'car name' #Здесь мы объявили атрибут класса, который на данный момент хранит в себе строку 
    def start_the_engine():
        print('Вы завели двигатель')
```
В выше указаном примере мы с вами допустили ошибку, которая на самом деле не позволит нам завести машину. 
Важно понять одну из основных особеностей ООП. Существует **Класс** и **Его экземпляр(Экземпляр класа / Объект класса)**

Если простым языком, то мы попытались описать в общем понимание класс Car, тоесть не конкретно какую-то машину, а некую  абстракцию,
на базе которой мы в дальнейшем будем создавать сами автомобили (всякие жигули, мазды, камазы и т.д.)
Пока это сложно понять, но дальше станет проще (наверное).

Итак, чтобы завести двигатель нашей машины, мы должны создать эту самую машину, давайте это сделаем:
```python
lada_priora = Car()
```
>Примечание: указав скобки после Car мы говори python создать **Объект класса**, если их не указать, то вы
> вместо объекта получите ссылку!

И затем вызовем ранее написанный нами метод start_the_engine
```python
lada_priora.start_the_engine()
```
При попытки вывода получим следующие сообщение:
```
Traceback (most recent call last):
  File "C:\Users\Mark\PycharmProjects\Grade+\Python_II\OOP\theory.py", line 9, in <module>
    lada_priora.start_the_engine()
TypeError: Car.start_the_engine() takes 0 positional arguments but 1 was given

```
Основной посыл лежит в этой строчке:
>TypeError: Car.start_the_engine() takes 0 positional arguments but 1 was given

Где нам говорят, что у нас ошибка, в которой буквально сказано "Метод класса Car.start_the_engine()
принимает в себя 0 аргументов, но ожидает 1."

Если простыми словами, то наш метод start_the_engine() создан внутри класса Car и он не умеет работать
с его экземплярами, так как мы его этому не научили. 
Для того чтобы метод сумел взаимодействовать с **экземляром / объектом класса** на необходимо дополнить
код класса ключевым словом self. 

```python
class Car:
    name = 'car name' #Здесь мы объявили атрибут класса, который на данный момент хранит в себе строку
    def start_the_engine(self):
        print('Вы завели двигатель')
```
И теперь результат исполнения программы будет иным:![img_1.png](img_1.png)

___
##Инкапсуляция
_Инкапсуляция_ - Это свойство которое объединяет данные и методы в классе, и скрывает их реализацию от пользователя.
Иными словами, это защищенность класса от его изменения пользователем. Так в python реализовано несколько уровней доступа
к внутреннему содержимому класса
___
##Полиморфизм
Тут текст про полиморфизм
___
##Наследование
Тут текст про наследование
___
